October 29:

	- design loose outline of project classes...I need:
		- data:
			- bank accounts
				- ID/token
				- status (open, closed, pending)
				- ~type (single, joint) (necessary?) 
				- funds
				- owner(s)
			- user profiles
				- ID/token
				- username, password
				- type (customer, employee, admin) (determines privileges)
				- owned accounts (only for customer)	 
			- transaction record
				- ID/token
				- timestamp
				- type (account open, account close, transfer, 
						deposit, withdrawal, user added/removed to/from account)
				- who (which user triggered it)
				- source account (only for transfer)
				- destination account (only for transfer)
				- transfer amount (only for transfer)	
		- DAO (text first, db later)
			- NOTE: for a bank, I think it makes sense to only read data on demand rather than
				load ALL of the data for one user that isn't allowed to look at them
			- name/identifier (eg filename, or database table-name/address)
			- read() @params: data type, id
			- write() @params: data object (account, profile, transaction)
		- user IO (command line)
			- notify() (print)
			- prompt() -> request (print + get input)
		- request (represents user input/commands)
			- type
			- additional param(s)
		- hub/main/primary/controller/teller/driver (connects everything and actually does the work)
			- currentUser (profile)
			- handleRequest()
			- interactionLoop()
			
	- some thoughts:
		- IDs for accounts, profiles, etc should be unique among each type of data, so I need
			to keep track of how many of each kind exist (or keep a "next ID")...shoudl this
			have its own class? or datatype? 
		- do user profiles need IDs or is the username enough?
	
	- I'm going to start on the data classes first. They are mostly just containers for data. [x]
		- should they inherit from an abstract class and/or implement an interface? How much do  
			they have in common? I guess they could be grouped in a single data structure at some
			point, so they should have some kind of polymorphism. Let's call it BankData [x]
			
	- I'm going to represent money with doubles, but I could make some kind of Money class that
		takes care of formatting, currency form, etc.
		
	- finished the data classes, I'll make a text DAO next. (and the general DAO interface) [ ]
		- I probably need an exception if the DAO runs in to problems
		
	- tomorrow, continue working on TextFileDAO, starting with searchFile(List)
	
October 30:

	- continue working on TextFileDAO [~]
		- writing entries is going to be more complicated than I thought, because it will involve
			reading the file and checking for an old entry to be overwritten (I guess the database
			version wont have this problem)
		- Let's unit test these search methods before moving on [x]
		- oh yeah if I want to test individual helper methods I cant set them to private
		- next time write/test writeMultiple()

November 2:

	- changed money representation to int [x]
	- now writeMultiple() [x] and test it [~]
	
November 3:

	- continue testing writeMultiple [x]
	- now start filling out the actual DAO interface methods that make use of these helpers
		I made [~]
		- I need more helpers
		- time to actually work out a format for transactions, why didn't I do this earlier? Oh right,
			the timestamp. I'm going to change it to a String because that's more flexible [x]
			- format will be "TRR <id> <time> <type> <actingUser> <sourceAcc> <destAcc> <moneyAmount>"
	- I just finished the buildTransaction method, tomorrow work on read
	
November 4:

	- I think I'm spending way too much time on the text DAO...I should be able to re-use some of this, though
	- anyway, on to the reading transactions [x]
	- now do write [x] and test it [x] 
		- oh no I had previously written a different way of doing write...time to fix this [x]
	- almost done with the TextDAO (finally...), I think I need a way to get the highest/next ID [x]
	- what to do next? The controller or the requests? I think request because the controller will need them.
	- What does a request need? Should there be different classes of request, or just a type enum?
		- Let's list the types of request:
			- register user (name, pass)
			- log in (name, pass)
			- log out
			- quit
			- apply to open account
			- approve opening an account (accID)
			- deny opening an account (accID)
			- close an account (accID)
			- add an owner to an account (accID, userID)
			- remove an owner from an account (accID, userID)
			- deposit money (accID, $)
			- withdraw money (accID, $)
			- transfer money (sourceAccID, destAccID, $)
			- view account(s) (accIDs, OR ownerUserID) (lead with a tag string saying what kind of ID)
			- view own user profile
			- view users (userIDs)
			- view transactions (trrIDs, OR userID, OR accID) (lead with a tag string saying what kind of ID)
			- create employee user (name, pass)
			- create admin user (name, pass)
		- seeing this, I think I'll just make one Request class. It will have:
			- a RequestType enum for each of the above
			- a List<String> params 
		- individual actions/methods will know how to parse these params and how to determine permissions.
	- okay, write the Request class [x] I don't think I need to test it
	
	- next, the BankSystem (still can't think of a better name)
	- what does it need?
		- reference to the IO (so I'll need to write that interface) [ ]
		- reference to the DAO
		- current user
		- interaction loop method (prompt IO, get request from IO, handle request)
		- helper methods for each of the request types
	- I think I will need an "InvalidPermission" exception, and maybe a "ImpossibleAction" exception
		- maybe just the ImpossibleAction, and the message will clarify why
		- the BankSystem will catch these and have the IO display the message to the user.
		- okay, make that exception class [x] no need to test, it's too basic
	- now I can start working on BankSystem [ ] 

November 5:

	- I need to add 4 more types of requests: log out, view transactions, view user, and view account(s) [x]
	- Make the BankIO interface so that the BankSystem class (and/or interface) can make use of it [x]
		- display() (string, or user, or List<Account>, or List<Transaction>)
		- prompt() (string)
	- now write the BankSystem class; I don't think I need an interface [ ]
	- big problem: how will the IO understand the prompt enough to create the right request? I have to rethink this
		- I think what I can do is have prompt() take a list/array of permitted RequestTypes in addition to any text.
			This way the IO will know what it can do. [x]
		- This system prevents many (but not all) of the ways someone could do something outside
			of their permissions
		- i made VIEW_USER plural
		- now that I made all of these method skeletons, I'm wondering if I should have made currentUser a
			parameter and if I should have made them return a value controlling whether or not the loop
			keeps running. That's more of a style thing than it is about functionality, and I can see advantages
			to both ways, so I'm just going to keep doing it this way.
	- i immediately realize that usernames should be unique, and that I need a way to check that. Time to add
		this to the DAO [x]
	- oh right I need a way to retrive user accounts by username [x]
	- oh yeah I need to allow for the creation of employee and admin accounts [x]
	- oh right I need to be recording transactions [ ], which will need timestamping...
		for now I'll have a placeholder
		- I will also need new methods in the DAO interface to search for transactions by user or account ID [x]
	- whew
	- tomorrow, resume working at handleRemoveACcountOwner method
	
November 6:

	- I'm wondering if/how I should test my BankSystem class...It's probably a good idea in the long run.
	- I can test it with the TextDAO and a mockIO class. The IO can be preloaded with a response Request
		in each test. We can use the mock and the dao to monitor the BS's output.
		- I could use this mockito thing to do the dao, but I don't want to take the time to learn it.
	- I will need to modify the BS slightly to make it only loop once if it's in a "test" mode. [x]
	- now write the MockIO class [x]
	- just realized I can add an easy universal permission check before hitting the big switch case [x]
	- now try some tests [x] okay I'm caught up, now I can do one method at a time
		- I'm leaning towards just testing that these methods do the right thing once the user has
			permission, otherwise I feel like I'm just testing java's if statements
	- in a few tests, I forgot to make sure that the users/accounts in question actually exist. I think I fixed them all.
	- tomorrow, continue working on depositing money
	
November 7:

	- crab dance
	- Continue from handle deposit
	- it occurs to me that maybe money should be long instead of int...but that's not a priority
	- when viewing multiple bank accounts, or multiple transactions, the params list in the Request will start with a
		tag string describing what they are. EG, if we want to look at a set of bank accounts, the list will be
		{"ACC", "101", "234", "583"}. If we want to look at all accounts owned by a user, the list will be
		{"PRF", "454"} to see all accounts owned by user #454. [x]
	- I think I'm going to change the DAO behavior on reading a non-existant data object to set the ID on the empty
		object to the requested ID, rather than -1. This way the user will see "User #454 does not exist" [F]
		- scratch that, I can have the BankSystem remember which ones weren't found and display that in a different message.
	- I think I need to add a RequestType for a customer viewing their own profile. This seems easier than checks [x]
	- finished bank system [x], tomorrow do the IO (and start the DBDAO?)
	
November 8: 

	- time to make the CLIO [X]
		- oh man this is WAY more work than I expected
	- created a BadMoneyFormatException for the CLIO [x]
	- I'm not sure how to unit test the IO but I can manually test what I've done so far, but ill need a Driver [x]
	- Just realized I never get to close the scanner...I'll add a quit method to the interface
	- Okay, the CLIO is ugly but done. Next the dbdao [ ]